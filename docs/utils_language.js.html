<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/language.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/language.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Language
 *
 * Helpers that deal with various aspects of the language
 */
export class Language {
  /**
   * Compose the properties of a set of objects into a target object. This will not
   * resolve getters/setters, but instead copy them. Apart from that, this function
   * is equivalent to Object.assign().
   *
   * @param target      The target object to compose the other objects into
   * @param ...sources  The source object(s) to compose into the target object
   * @returns {*}       The composed object, this is simply the target
   */
  static compose(target, ...sources) {
    for (const source of sources) {
      for (const prop in source) {
        Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
      }
    }
    return target;
  }

  /**
   * Returns a new deep copy of the object with any null values removed. This is useful during
   * serialization to remove any null values, assuming that objects are initialized with null
   * values for default values.
   * @param obj
   */
  static deflate(obj) {
    const deflated = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const v = obj[key];
        if (v &amp;&amp; v.constructor.name === "Object") {
          const child = Language.deflate(v);
          if (Object.keys(child).length > 0) {
            deflated[key] = child;
          }
        } else if (v !== undefined &amp;&amp; v !== null &amp;&amp; (!Array.isArray(v) || v.length > 0)) {
          deflated[key] = v;
        }
      }
    }
    return deflated;
  }

  /**
   * Performs a deep copy of source into target, but only copying fields that already exist in the target.
   * @param target
   * @param source
   * @returns {*} Returns the target object
   */
  static assignOverwrite(target, source) {
    if (source) {
      for (const key in target) {
        if (target.hasOwnProperty(key) &amp;&amp; source.hasOwnProperty(key)) {
          if (target[key] &amp;&amp; target[key].constructor.name === "Object") {
            Language.assignOverwrite(target[key], source[key]);
          } else {
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="View.html">View</a></li></ul><h3>Classes</h3><ul><li><a href="Fragment.html">Fragment</a></li><li><a href="Language.html">Language</a></li><li><a href="Route.html">Route</a></li><li><a href="UndoStack.html">UndoStack</a></li><li><a href="View.Spline.html">Spline</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createJSX">createJSX</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.3</a>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
